# 4.15 Задачи на рекурсию. rusMult Русский крестьянский способ умножения

*"Умножение - мое мучение, ..."*  

* Русские крестьяне таблицу умножения не учили. Им приходилось иметь дело с разными системами счисления: для определения дат, измерения расстояний, весов, расчетов с купцами из разных стран и т.д.  
Поэтому русский крестьянин безошибочно умел выполнять операции сложения и вычитания, а также умножения и деления на 2.  
* Для умножения двух целых чисел a и b использовался следующий алгоритм. Большее число - это a, а меньшее - b.
  * Число b делилось на 2 с остатком.
    * Если остаток получался 1, то промежуточный результат (будущее произведение) увеличивался на a.
  * Затем a увеличивалось вдвое.
* Эти действия производились до тех пор, пока b было больше 0. Промежуточный результат становился результатом умножения.  
Написать рекурсивную функцию  
`int rusMult(int a, int b)`  
которая реализует этот алгоритм и возвращает результат умножения.  
* Таблица вызываемых значений (рекурсивный спуск)  
**`| a    | b    | b%2    | res вернулся при этом вызове  | new_res, вернёт этот вызов|`**  
`|------|------|--------|-------------------------------|---------------------------|`  
`| 100  | 37   | 1      | ?                             | ?                         |`  
`| 200  | 18   | 0      | ?                             | ?                         |`  
`| 400  | 9    | 1      | ?                             | ?                         |`  
`| 800  | 4    | 0      | ?                             | ?                         |`  
`| 1600 | 2    | 0      | ?                             | ?                         |`  
`| 3200 | 1    | 1      | ?                             | ?                         |`  
`|----------------------------------------------------------------------------------|`  
  
* Таблица возвращаемых значений (возврат из рекурсивных вызовов)  
Заполняем таблицу снизу вверх, вместо ? пишем возвращаемые значения и те значения, которые мы хотим вернуть.  
**`| a    | b    | b%2    | res вернулся при этом вызове  | new_res, вернёт этот вызов|`**  
`|------|------|--------|-------------------------------|---------------------------|`  
`| 100  | 37   | 1      | 3600                          | 3700                      |`  
`| 200  | 18   | 0      | 3600                          | 3600                      |`  
`| 400  | 9    | 1      | 3200                          | 3600                      |`  
`| 800  | 4    | 0      | 3200                          | 3200                      |`  
`| 1600 | 2    | 0      | 3200                          | 3200                      |`  
`| 3200 | 1    | 1      | -                             | 3200                      |`  
`|----------------------------------------------------------------------------------|`  

* Для проверки работы алгоритма организовать печать всех величин на всех итерациях работы алгоритма. В проверяющую систему послать всю программу.  
  
* **Входные данные**  
Два целых числа через пробел, не более 10^4.  

* **Выходные данные**  
Промежуточные значения вычислений через пробел.  
  * Рекурсивный спуск: печать **a** и **b**
    * В последнем вызове **b=1**
  * Возврат из рекурсивных вызовов (каждый промежуточный вычисленный результат на отдельной строке):
    * В первой строке - последнее значение **a**, в примере 3200.
    * В последующих строках через пробел:
      * **res**, первое число - возвращенное значение функции;
      * **a**, переданное в этот вызов функции;
      * **ost**, остаток от деления b на 2;
      * **new_res**, вновь вычисленный результат, (который будет возвращен)
    * Последняя строка - результат, возвращенный в функцию main(), в примере 3700.  

Последняя строка - искомое произведение.  
**Посылать всю программу.**  

**Sample Input:**  
100 37  
**Sample Output:**  
100 37  
200 18  
400 9  
800 4  
1600 2  
3200 1  
3200  
3200 1600 0 3200  
3200 800 0 3200  
3200 400 1 3600  
3600 200 0 3600  
3600 100 1 3700  
3700  
