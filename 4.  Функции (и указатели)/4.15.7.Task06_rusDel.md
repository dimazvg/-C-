# 4.15 Задачи на рекурсию. Task06. rusDel Русский крестьянский способ деления (без остатка)

* *"Умножение - мое мучение, а с делением совсем беда.."*  

* Русские крестьяне таблицу умножения не учили. Им приходилось иметь дело с разными системами счисления: для определения дат, измерения расстояний, весов, расчетов с купцами из разных стран и т.д.  
Поэтому русский крестьянин безошибочно умел выполнять операции сложения и вычитания, а также умножения и деления на 2.  
Для деления целого числа **a** на нечетное целое **b** использовался следующий алгоритм.  

## **Часть 1. Спуск до 0**

* Если делимое a - четное, то
  * a делится пополам до тех пор пока оно не ставится нечетным,
  * после чего из него вычитается b.
* При этом запоминается множитель для будущих вычислений.
  * После каждого деления промежуточный множитель `mult` становится равен 2, а слагаемое `rem` 0.
  * Если же происходило вычитание, множитель `mult` будет 1, а слагаемое `rem` 1.
* Так происходит до тех пор пока результат вычитания не станет равен 0.  

* Таблица рекурсивного спуска при делении **a=77** на **b=7**:  
`| a      | a четное?    | что делаем    | mult    | rem    | формула частичного результата, part |`  
`|--------|--------------|---------------|---------|--------|-------------------------------------|`  
`| 77     | нет          | -b            | 1       | 1      | ?                                   |`  
`| 70     | да           | /2            | 2       | 0      | ?                                   |`  
`| 35     | нет          | -b            | 1       | 1      | ?                                   |`  
`| 28     | да           | /2            | 2       | 0      | ?                                   |`  
`| 14     | да           | /2            | 2       | 0      | ?                                   |`  
`| 7      | нет          | -b            | 1       | 1      | ?                                   |`  
`| 0      |              | -             | -       | -      | -                                   |`  
`--------------------------------------------------------------------------------------------------`

* При рекурсивном спуске печатаем:
  * **a** для следующего шага (0 уже не печатаем!)
  * **mult** промежуточный множитель
  * **rem** слагаемое  

`70 1 1`  
`35 2 0`  
`28 1 1`  
`14 2 0`  
`7 2 0`  


## **Часть 2. Вычисление результата**

* При вычислении результата на каждом этапе предыдущий результат (начиная с последней 1) умножается на сомножитель (1 или 2), и к нему прибавляется слагаемое (0 или 1).  
`part = part * mult + rem`  
После этого полученный результат используется для дальнейших вычислений пока не получен последний результат.  

* Таблица рекурсивного подъема (заполняем ее снизу вверх) и вычисления результата:  
`| a      | a четное?    | что делаем    | mult    | rem    | формула частичного результата | part                  |`  
`|--------|--------------|---------------|---------|--------|-------------------------------|-----------------------|`  
`| 77     | нет          | -b            | 1       | 1      | 10*1+1=11                     | 11                    |`  
`| 70     | да           | /2            | 2       | 0      | 5*2+0=10                      | 10                    |`  
`| 35     | нет          | -b            | 1       | 1      | 4*1+1=5                       | 5                     |`  
`| 28     | да           | /2            | 2       | 0      | 2*2+0=4                       | 4                     |`  
`| 14     | да           | /2            | 2       | 0      | 1*2+0=2                       | 2                     |`  
`| 7      | нет          | -b            | 1       | 1      | 0*1+1=1                       | можно сразу вернуть 1 |`  
`| 0      |              | возвращаемся  | -       | -      | -                             |                       |`  
`--------------------------------------------------------------------------------------------------------------------`  

* При возвращении из рекурсивно вызванных функций печатаем:
  * 1 (из строки "можно сразу вернуть 1" в таблице)
  * каждый промежуточный результат на отдельной строке в виде
    * `part * mult + rem = new_part`
    * все числа и знаки в этом выражении должны быть разделены пробелом
  * в `main` отдельно печатаем результат деления  

```// вывод
1
1 * 2 + 0 = 2
2 * 2 + 0 = 4
4 * 1 + 1 = 5
5 * 2 + 0 = 10
10 * 1 + 1 = 11
11
```

* Написать рекурсивную функцию  
`int rusDel(int a, int b);`  
которая реализует этот алгоритм (деления целого без остатка на нечетное число) и возвращает результат умножения. Для проверки работы алгоритма организовать печать всех величин на всех итерациях работы алгоритма.  
**Посылать всю программу.**  

**Sample Input:**  
77 7  
**Sample Output:**  
70 1 1  
35 2 0  
28 1 1  
14 2 0  
7 2 0  
1  
1 \* 2 \+ 0 = 2  
2 \* 2 \+ 0 = 4  
4 \* 1 \+ 1 = 5  
5 \* 2 \+ 0 = 10  
10 \* 1 \+ 1 = 11  
11  
